<?php


/*************************************************************************************************************
Configuration set
*************************************************************************************************************/

// Set to TRUE to show the message when an exception occurs
define('SHOW_EXCEPTION', false);

// Force an EXIT when an exception occurs
define('FORCE_EXIT_WHEN_EXCEPTION', true);

// Database URL
define('DATABASE_URL', '');

// Database name
define('DATABASE_NAME', '');

// Database username
define('DATABASE_USERNAME', '');

// Database password
define('DATABASE_PASSWORD', '');

// Keys to be used on Hash generation. These two Keys works together.
define('HASH_KEY_1', '0D7B46F8A');
define('HASH_KEY_2', '9A35ACCD56FE');

// This is the label to indicate the HASH code into the log information
define('HASH_LABEL', '::HASH::');


/*************************************************************************************************************
Database exception
*************************************************************************************************************/

function ShowExceptionMessage($str)
{
    /**
    Provide a better message when an SQL exception happens.

    :param $str String:
        A message to show when an error happens
    */

    // Show a generic message when an exception occurs
    echo 'Sorry about this inconvenient. The administrator received an email with this error and soon he will contact you.';

    // Show the exception message generated by the database
    if (SHOW_EXCEPTION) {
        echo $str;
    }

    // Force EXIT
    if (FORCE_EXIT_WHEN_EXCEPTION) {
        exit;
    }
}


/*************************************************************************************************************
Query and Prepare statement audition
*************************************************************************************************************/

function SaveSqlQuery($sp, $sql, &$_conexao, &$_qry)
{
    /**
    */

    global $_LOGIN__usu_id;

    $descricao = $sql."\n\n".$_qry->GetParameter();

    $qry = $_conexao->prepare('CALL '.$sp.' (:usu_id, :descricao);');
    $qry->bindParam(':usu_id', $_LOGIN__usu_id);
    $qry->bindParam(':descricao', $descricao);
    $qry->execute();
}


/*************************************************************************************************************
Database transaction class
*************************************************************************************************************/

class Transaction {
    /**
    Class to manipulate transactions on a PDO Connection
    */

    // TRUE if a transaction is active to avoid duplicate "start" command
    private static $transaction_is_activated = false;

    // Database Connection object
    public static $connection;


    public static function Start()
    {
        /**
        Initiae a transaction. If we already have an activate one, just pass

        :return BOolean:
            TRUE if the transaction was open here.
            FALSE if the transaction is already opened.
        */

        // If the transaction is already active, it is not necessary to continue here
        if (self::$transaction_is_activated) {
            return false;
        }

        // Open a database connection
        self::$connection = ConPdo::getInstance();

        // Start a transaction
        self::$connection->beginTransaction();
        self::$transaction_is_activated = true;

        return true;
    }


    public static function Commit()
    {
        /**
        Commit an active transaction and close its connection
        */

        // Terminate the transaction with a Commit
        self::$connection->commit();
        self::$transaction_is_activated = false;

        // Close the database connection
        self::$connection->close();
    }


    public static function Rollback($error_message, $force_exit)
    {
        /**
        Rollback an active trancation and close its connection
        */

        // Terminate the transaction with a ROllback
        self::$connection->rollback();
        self::$transaction_is_activated = false;

        // Close the database connection
        self::$connection->close();

        // Show the error message
        ShowExceptionMessage($error_message);

        // Force the EXIT
        if ($force_exit) {
            exit;
        }
    }


    public static function ExecutePrepare($sql)
    {
        /**
        Execute the Prepare statement into the Connection object stored in this class

        :param $sql String:
            The SQL statement

        :return Object:
            The Prepare statement from the Connection object
        */
        return self::$connection->prepare($sql);
    }
}


class ConPdoStatement extends PDOStatement {

    // Parameters used in this statement
    // This variable is only used by Log Audition
    private static $parameters = array();

    // The PDO object
    protected $PDO = null;

    // Time spent by the last execution
    protected $execution_time = 0;

    // This is the KEY used to generate HASH verification
    private static $HASH_KEY = array(HASH_KEY_1, HASH_KEY_2);


    protected function __construct(PDO &$PDO)
    {
        /**
        Constructor class.
        Start the Execution Time variable
        */
        $this->PDO = $PDO;
        $this->execution_time = microtime(true);
    }


    final public function GetExecutionTime($decimal_precision=4)
    {
        /**
        Get the Execution Time spent by the last statement

        :param $decimal_precision Integer:
            Number of decimal places

        :return String:
            The Execution Time variable content
        */
        return number_format($this->execution_time, $decimal_precision, '.', ',');
    }


    final public function execute($input_parameter=null)
    {
        /**
        Makes a detour so we can compute the execution_time variable

        :param $imput_parameter Array:
            THe parameters passed to the parent Execute function

        :return Object:
            The parent Execute result
        */
        if ($execute_result = parent::execute($input_parameter)) {
            $this->execution_time = microtime(true) - $this->execution_time;
        }

        return $execute_result;
    }


    private function AddParameter($name, $value, $type)
    {
        /**
        Include a new parameter

        :param $name String:
            The name of the field

        :param $value:
            The value of the field
            Can be any type

        :param $type String:
            The type of the value will be store into the field
        */
        self::$parameters[] = array(
            'name' => $name,
            'value' => ($value === NULL ? 'NULL' : $value),
            'type' => $type
        );
    }


    private function GenerateHashValidation($text)
    {
        /**
        Generate a Hash information according the Text pased by parameter

        :param $text String:
            The text to generate the Hash

        :result $text:
            The Hash code
        */
        return md5(md5($text.self::$HASH_KEY[0]).self::$HASH_KEY[1]);
    }


    private function AddHashValidation(&$text)
    {
        /**
        Add Hash verification into the String passed by parameter.
        This function have the parameter by reference, so it is not needed to return anuthing.

        :param &$text String:
            The string where we will add the HASH verification
        */
        $text .= HASH_LABEL.$this->GenerateHashValidation($text);
    }


    public function GetStatementAudit()
    {
        /**
        Get the formated audit information with the Hash verification
        */

        // The audit information
        $text =
             '--------------------------------------------------------------------------------'
            ."\n\n"
            .'Audit log generated: '.date('Y-m-d H:i:s.u')
            ."\n\n\n"
            .'--- Statement: '
            ."\n\n"
            .$this->queryString
            ."\n\n"
            .'Execution time: '.$this->GetExecutionTime(4)
            ."\n\n\n"
            .'--- Statement parameters:'
            ."\n\n"
            .$this->GetParameter()
            ."\n"
            .'--- Session parameters:'
            ."\n\n"
            .(isset($_SERVER['USER']) ? 'USER: '.$_SERVER['USER']."\n" : '')
            .'HTTP_HOST: '.$_SERVER['HTTP_HOST']."\n"
            .'SCRIPT_FILENAME: '.$_SERVER['SCRIPT_FILENAME']."\n"
            .'SCRIPT_NAME: '.$_SERVER['SCRIPT_NAME']."\n"
            .'HTTP_USER_AGENT: '.$_SERVER['HTTP_USER_AGENT']."\n"
            .(isset($_SERVER['HTTP_X_FORWARDED_PORT']) ? 'HTTP_X_FORWARDED_PORT: '.$_SERVER['HTTP_X_FORWARDED_PORT']."\n" : '')
            .(isset($_SERVER['HTTP_X_FORWARDED_PROTO']) ? 'HTTP_X_FORWARDED_PROTO: '.$_SERVER['HTTP_X_FORWARDED_PROTO']."\n" : '')
            .(isset($_SERVER['HTTP_X_FORWARDED_FOR']) ? 'HTTP_X_FORWARDED_FOR: '.$_SERVER['HTTP_X_FORWARDED_FOR']."\n" : '')
            .(isset($_SERVER['REDIRECT_STATUS']) ? 'REDIRECT_STATUS: '.$_SERVER['REDIRECT_STATUS']."\n" : '')
            .'SERVER_NAME: '.$_SERVER['SERVER_NAME']."\n"
            .'SERVER_PORT: '.$_SERVER['SERVER_PORT']."\n"
            .'SERVER_ADDR: '.$_SERVER['SERVER_ADDR']."\n"
            .'REMOTE_PORT: '.$_SERVER['REMOTE_PORT']."\n"
            .'REMOTE_ADDR: '.$_SERVER['REMOTE_ADDR']."\n"
            .'REQUEST_METHOD: '.$_SERVER['REQUEST_METHOD']."\n"
            .'REQUEST_SCHEME: '.$_SERVER['REQUEST_SCHEME']."\n"
            ."\n\n"
            ;

        // Add the  Hash verification into the audit information
        self::AddHashValidation($text);

        return $text;
    }


    public function ValidateStatementAudit($text)
    {
        /**
        Validate our log information

        :param $text String:
            The complete log information

        :return Boolean:
            TRUE if the hash verification into the $text parameter really matches
        */

        // Try to find the log and hash information
        $pattern = '/(.+)'.HASH_LABEL.'(.{32})$/s';
        preg_match($pattern, $text, $matches);

        // If we don`t have excatly 3 itens in the match array, so we couldn`t find the HASH verification
        if (count($matches) != 3) {
            return false;
        }

        // Store into variables the Log information and the Hash verification
        $log = $matches[1];
        $hash = $matches[2];

        // Matches only if the extracted Hash is the same as the generated hash
        return ($hash === $this->GenerateHashValidation($log));
    }


    public function GetParameter()
    {
        /**
        Get all the parameters including its names, values and value types

        :return :String
            A formatted string containing the parameters information
        */
        $parameters_count = count(self::$parameters);
        $txt = 'Parameters quantity: '.$parameters_count."\n\n";
        for ($i = 0; $i < $parameters_count; $i++) {
            $txt .=
                 'Parameter: "'.self::$parameters[$i]['name'].'"'."\n"
                .'Value: "'.self::$parameters[$i]['value'].'"'."\n"
                .'Type: "'.self::$parameters[$i]['type'].'"'."\n"
                ."\n";
        }
        return $txt;
    }


    function getPDOConstantType($var)
    {
        /**
        Find the correct type of the variable. This will be used internally on the BindParam statement

        :param $var:
            Can be any type

        :return PDO TYPE CONSTANT:
            THe type of the variable according to the PDO rules
        */

        // If the variable is an integer value
        if (is_int($var)) return PDO::PARAM_INT;

        // If the variable is a Boolean value
        if (is_bool($var)) return PDO::PARAM_BOOL;

        // If the variable is Null
        if (is_null($var)) return PDO::PARAM_NULL;

        // The default
        return PDO::PARAM_STR;
    }


    public function bindParam($paramno, &$param, $type=null, $maxlen=null, $driverdata=null)
    {
        /**
        Follow exactly bindParam parent function, making transarent for the programer the use of our AddParameter function

        :param $paramno String:

        :param &$param:
            Can be any type. It is the value for the field.
            THis is passed as a reference to avoid unecessary memory usage.

        :param $type=null:
            Used in the parent function bindParam

        :param $maxlen=null:
            Used in the parent function bindParam

        :param $driverdata=null:
            Used in the parent function bindParam

        :return Object:
            Return the parent bindParameter result
        */

        // Find the type of the value to this field
        $type = self::getPDOConstantType($param);

        // Add a new parameter
        $this->AddParameter($paramno, $param, $type);

        // Return the parent bindParam result function
        return parent::bindParam($paramno, $param, $type, $maxlen, $driverdata);
    }


    public function fetch($how=NULL, $orientation=NULL, $offset=NULL)
    {
        /**
        Execute the parent Fetch statement using FETCH_ASSOC as a default value to HOW Fetch function parameter

        :param $orientation=NULL:
            Used in the parent Fetch function

        :param $offset=NULL:
            Used in the parent Fetch function

        :return Object:
            Return the parent Fetch function
        */

        return parent::fetch(PDO::FETCH_ASSOC, $orientation, $offset);
    }
}


/*************************************************************************************************************
Inherited PDO class
Provide aditional features to PDO class
*************************************************************************************************************/

/**
A model to be used to generate the URL to database connection
*/
interface DatabaseConnection {

    // Function that generate the string to the database connection
    public static function DnsConnection();
}

/**
This class implements DatabaseConnection and generate the URL for a MySQL database.
The URL and the Database Name needs to be provided by a "define" php command
*/
class MySQLDatabaseConnection implements DatabaseConnection {

    public static function DnsConnection()
    {
        /**
        Generate the string that will be the URL to the database connection

        :return String:
            The URL to be the database connection
        */
        return 'mysql:host='.DATABASE_URL.';dbname='.DATABASE_NAME.';charset=utf8';
    }
}

/**
The main database class.
*/
class ConPdo extends pdo {

    // State of the connection
    private static $connected = false;

    // Object to the connection. This ensure a Singleton method
    private static $instance = null;


    public function __construct($dns, $username, $password)
    {
        /**
        Just call the parent constructor

        :param $dns String:
            The DNS connection

        :param $username String:
            The database username

        :param $password String:
            The database password
        */
        parent::__construct($dns, $username, $password);
    }


    public function  __destruct()
    {
        /**
        Ensure that the instante will be destroyed when the it is close
        */
        self::$instance->close();
        self::$instance = null;
    }


    public function close()
    {
        /**
        Close the connection
        */
        if (self::$connected) {
            parent::close();
            self::$connected = false;
        }
    }


    public static function getInstance()
    {
        /**
        Control the singleton working.
        We never should call the creator of this class direct, instead of this we call this static function.
        Here we check if we already have an active instance. If yes, just return it. If no, we create a new one.

        :return Object:
            The database instance already opened
        */

        // If we not have an active instance, we create a new one
        if (!isset(self::$instance)) {
            try {

                // Ensure we always have an UTF-8 charset connection
                $opt = array(PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES UTF8');

                // Create and open the database connection
                self::$instance = new self(MySQLDatabaseConnection::DnsConnection(), DATABASE_USERNAME, DATABASE_PASSWORD, $opt);
                self::$instance->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

                // Ensure that the Prepate statement will be fetched using name associations
                self::$instance->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
            }
            catch (PDOException $e) {
                die (ShowExceptionMessage($e->getMessage()));
            }
        }

        // Return the previews instance or the created one above
        return self::$instance;
    }


    public function query($sql, $params = array())
    {
        /**
        Override the Query function replacing by the Prepare function

        :return Object:
            The object after the "Execute" statement
        */
        $stmt = $this->prepare($sql);
        $stmt->execute($params);

        return $stmt;
    }


    public function prepare($sql, $options = null)
    {
        /**
        Override the Prepare function. Right after that, we override the default Fetch behavior by ours.
        With this, we can override the functions presents in the Prepare statemment

        :return Object:
            The object after the "Prepare" statement
        */

        // Execute the Prepare command passing our own class to act as statement class
        $stmt = parent::prepare($sql, array(
            PDO::ATTR_STATEMENT_CLASS => ['ConPdoStatement', [&$this]]
        ));

        // Ensure that the Prepate statement will be fetched using name associations
        $stmt->setFetchMode(PDO::FETCH_ASSOC);

        // Return the Statemment (our statement class)
        if ($stmt) {
            return $stmt;
        }
        else {
            throw new Exception('Query Exception: '.parent::errorInfo().' (number:'.parent::errorCode().')');
        }
    }
}

